pipeline {
    agent any

    options {
        //  Specifying how many artifacts and logs we want to persist. 
        //  In this case we are going to persist the last 10 builds.
        buildDiscarder(logRotator(numToKeepStr: '10'))
        // Disallows concurrent executions of the Pipeline.
        disableConcurrentBuilds()
        // Sets a timeout period for the Pipeline run, after which Jenkins should abort the Pipeline.
        // Our timeout is 1 hour. This is a good practice to prevent infinite blocks in our Jenkins.
        timeout(time: 1, unit: 'HOURS')
        // Prepends all console output generated by the Pipeline run with the time at which the line was emitted.
        timestamps()
    }

    tools {
        dockerTool 'docker-latest'
    }

    environment {
        IMAGE_VERSION = "${env.BUILD_ID}"
        AWS_ECR_REGION = 'ap-southeast-2'
        AWS_ECS_SERVICE = 'test-backend-service'
        AWS_ECS_TASK_DEFINITION = 'test-backend'
        AWS_ECS_COMPATIBILITY = 'FARGATE'
        AWS_ECS_NETWORK_MODE = 'awsvpc'
        AWS_ECS_CPU = '256'
        AWS_ECS_MEMORY = '512'
        AWS_ECS_CLUSTER = 'a-comosus-cluster'
        AWS_ECS_TASK_DEFINITION_PATH = './CI-CD/ecs/backend-container-definition-update-image.json'
    }



    
    stages {

        stage('Cleanup docker space') {
            steps {
                echo 'Cleanup docker space'
                sh 'docker system prune -f'
            }
        }

        stage('Git check out') {
            steps{
                echo 'Git check out...'
                // Get source code from a GitHub repository
                git branch: env.BRANCH_NAME, url:'https://github.com/A-Comosus/comosus-server.git'
            }
        }

        stage('Install dependencies') {
            steps {
                echo 'Install dependencies...'
                sh 'yarn install'
            }
        }

        // stage('Test') {
        //     steps {
        //         echo 'Testing..'
        //         sh 'npm run test:coverage'
        //     }
        // }
        
        stage('Checking for linter error') {
            steps {
                echo 'Checking for linter error....'
                sh 'yarn lint'
            }
        }

        // stage ('Integrated Test') {
        //     steps {
        //         echo 'Integrated Test....'
        //         sh
        //     }
        // }

        stage('Build') {
            steps {
                echo 'Building....'
                sh 'yarn prisma generate'
                sh 'yarn build'
            }
        }

        // stage ('Container Integrated Test') {
        //     steps {
        //         echo 'Container Integrated Test....'
        //         sh
        //     }
        // }

        stage('Build and Upload Image to ECR') {
            
            when {
                anyOf {
                    branch 'develop'
                    branch 'CI-CD/*'
                }
            }

            steps {
                echo 'build image with ecr tage...'
                withCredentials([string(credentialsId: 'AWS_REPOSITORY_URL_SECRET_BACKEND', variable: 'AWS_ECR_URL')]) {
                    sh "docker build -t ${AWS_ECR_URL}:${IMAGE_VERSION} ."
                }

                echo 'upload to ECR'
                withCredentials([string(credentialsId: 'AWS_REPOSITORY_URL_SECRET_BACKEND', variable: 'AWS_ECR_URL')]) {
                    withAWS(region: "${AWS_ECR_REGION}", credentials: 'AWS_Credentials') {
                        script {
                            def login = ecrLogin()
                            sh('#!/bin/sh -e\n' + "${login}") // hide logging
                            docker.image("${AWS_ECR_URL}:${IMAGE_VERSION}").push()
                        }
                    }
                }
            }
        }

        stage('Deploy to ECS service') {

            when {
                anyOf {
                    branch 'develop'
                    branch 'CI-CD/*'
                }
            }

            steps {
                echo 'Update to ECS service'
                withCredentials([string(credentialsId: 'AWS_EXECUTION_ROL_SECRET', variable: 'AWS_ECS_EXECUTION_ROL'),string(credentialsId: 'AWS_REPOSITORY_URL_SECRET_BACKEND', variable: 'AWS_ECR_URL')]) {
                    withAWS(region: "${AWS_ECR_REGION}", credentials: 'AWS_Credentials') {
                        script {
                                updateContainerDefinitionJsonWithImageVersion()
                                sh("/usr/local/bin/aws ecs register-task-definition --region ${AWS_ECR_REGION} --family ${AWS_ECS_TASK_DEFINITION} --execution-role-arn ${AWS_ECS_EXECUTION_ROL} --requires-compatibilities ${AWS_ECS_COMPATIBILITY} --network-mode ${AWS_ECS_NETWORK_MODE} --cpu ${AWS_ECS_CPU} --memory ${AWS_ECS_MEMORY} --container-definitions file://${AWS_ECS_TASK_DEFINITION_PATH}")
                                //def taskRevision = sh(script: "/usr/local/bin/aws ecs describe-task-definition --task-definition ${AWS_ECS_TASK_DEFINITION} | egrep \"revision\" | tr \"/\" \" \" | awk '{print \$2}' | sed 's/\"\$//'", returnStdout: true)
                                sh("/usr/local/bin/aws ecs update-service --cluster ${AWS_ECS_CLUSTER} --service ${AWS_ECS_SERVICE} --task-definition ${AWS_ECS_TASK_DEFINITION}")
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            withCredentials([string(credentialsId: 'AWS_REPOSITORY_URL_SECRET_BACKEND', variable: 'AWS_ECR_URL')]) {
                deleteDir()
                // sh "docker rmi ${AWS_ECR_URL}:${IMAGE_VERSION}"
            }
        }
    }
}

def updateContainerDefinitionJsonWithImageVersion() {
    def containerDefinitionJson = readJSON file: AWS_ECS_TASK_DEFINITION_PATH, returnPojo: true
    containerDefinitionJson[0]['image'] = "${AWS_ECR_URL}:${IMAGE_VERSION}".inspect()
    echo "task definiton json: ${containerDefinitionJson}"
    writeJSON file: AWS_ECS_TASK_DEFINITION_PATH, json: containerDefinitionJson
}